% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/derivs.R
\name{grad_ft}
\alias{grad_ft}
\title{devirs of double logistics functions (analytical resolution)}
\usage{
grad_ft(FUN)
}
\description{
Analytical derivative can also have some weird result. `numDeriv`'s result
was accurate enough.
}
\details{
Enclosure env of `ans` was this funcion's execution env. But environment of
C language based deriv function was wired.

grad is the first order derivative, and hess is the second order derivative.
`f` means function, generated from `deriv` function
`e` means expression, generated from `D` or `D` function

gradf_t   : gradient function f(par, t) (from the aspect of t)
hessf_t   : hessian  function f(par, t) (from the aspect of t)
grade_t   : gradient expression function f(par, t), get values through `eval`, (from the aspect of t)
hesse_t   : gradient expression function f(par, t), get values through `eval`, (from the aspect of t)

grad_fpar : gradient function f(par, t), get values through `eval`, (from the aspect of t)
hess_fpar : hessian  function f(par, t), get values through `eval`, (from the aspect of t)
}
\examples{
#'grade_t' only cost 3/4 time of 'gradf_t'
#'hesse_t' used more 1/2 times of 'hessf_t'
microbenchmark(
    gradf_t(FUN)(par,t),
    grade_t(FUN)(par,t))
microbenchmark(
 hessf_t(FUN)(par,t),
 hesse_t(FUN)(par,t))
}
