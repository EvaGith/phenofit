#' @name phenofit_process
#' @title phenofit_process
NULL

# Select the data of specific site. Only those variables \code{c('t', 'y', 'w')} selected.
#' @rdname phenofit_process
#' @export
getsite_data  <- function(df, sitename, dateRange = NULL){
    d <- dplyr::select(df[site == sitename, ], dplyr::matches("t|y|w|QC_flag"))
    # if has no \code{QC_flag}, it will be generated by \code{w}.

    # filter dateRange
    if (!(missing(dateRange) || is.null(dateRange))) {
        bandname <- intersect(c("t", "date"), colnames(d))[1]
        dates    <- d[[bandname]]
        I <- dates >= dateRange[1] & dates <= dateRange[2]
        d <- d[I, ]
    }
    d
    #%T>% plot_input(365)
}

#' @rdname phenofit_process
#' @export
getsite_INPUT <- function(df, st, sitename, nptperyear, dateRange = NULL){
    sp_point <- st[site == sitename, ]
    south    <- sp_point$lat < 0
    name     <- sp_point$name %>% {ifelse(is.null(.), "", paste0(", ", .))}
    IGBP     <- sp_point$IGBP %>% {ifelse(is.null(.), "", paste0(., ", "))}

    titlestr <- sprintf("[%s%s] %s lat = %.2f", sitename, name, IGBP, sp_point$lat)
    d <- getsite_data(df, sitename, dateRange)

    dnew     <- add_HeadTail(d, south = south, nptperyear = nptperyear)
    INPUT    <- check_input(dnew$t, dnew$y, dnew$w, QC_flag = dnew$QC_flag,
        nptperyear = nptperyear, south = south,
        maxgap = nptperyear/4, alpha = 0.02,
        wmin = 0.6, ymin = 0.1)

    INPUT$titlestr <- titlestr
    INPUT
}

#' @description
#' \describe{
#'   \item{phenofit_season}{ Calculate growing season dividing information}
#'   \item{phenofit_finefit}{Fine fitting}
#' }
#'
#' @param INPUT An object returned by \code{check_input}
#' @param options options of phenofit
#' @param IsPlot whether to plot season dividing procedure?
#' @param ... other parameters to \code{\link{season_mov}} or \code{\link{season}}
#'
#' @return same object returned by \code{\link{season_mov}} and \code{\link{season}}
#'
#' @rdname phenofit_process
#' @export
phenofit_season <- function(INPUT, options, IsPlot = FALSE, verbose = TRUE, ...)
{
    param <- list(
        FUN_season     = options$FUN_season,
        rFUN           = options$FUN_rough,
        wFUN           = options$wFUN_rough,
        iters          = options$iters_rough,
        lambda         = options$lambda,
        nf             = options$nf,
        frame          = options$frame,
        maxExtendMonth = options$max_extend_month_rough,
        rtrough_max    = options$rtrough_max,
        r_max          = options$r_max,
        r_min          = options$r_min,
        calendarYear   = options$calendarYear,
        # caution about the following parameters
        minpeakdistance   = INPUT$nptperyear/6,
        MaxPeaksPerYear   = 3,
        MaxTroughsPerYear = 4,
        IsPlot            = FALSE,
        IsPlot.OnlyBad    = FALSE,
        ypeak_min         = 0.1,
        print             = FALSE,
        ...
    )

    if (verbose){
        fprintf("----------------------------------\n")
        fprintf("Growing season dividing parameters:\n")
        fprintf("----------------------------------\n")
        print(str(param, 1))
    }

    FUN_season <- get(param$FUN_season)
    param <- param[-1]

    if (!is.function(param$rFUN)) param$rFUN %<>% get()
    if (!is.function(param$wFUN)) param$wFUN %<>% get()

    # print(sprintf('nptperyear = %d', INPUT$nptperyear))
    # param <- lapply(varnames, function(var) input[[var]])
    param <- c(list(INPUT = INPUT), param)
    brks <- do.call(FUN_season, param) # brk return

    if (IsPlot){
        abline(h = 1, col = "red")
        title(INPUT$titlestr)
    }
    return(brks)
}

#' @param brks object returned by \code{\link{season_mov}} and \code{\link{season}}
#' @inheritParams get_pheno
#'
#' @rdname phenofit_process
#' @export
phenofit_finefit <- function(INPUT, brks, options,
    TRS = c(0.2, 0.5, 0.6), ...)
{
    param <- list(
        INPUT, brks,
        iters          = options$iters_fine,
        methods        = options$FUN_fine, #c("AG", "zhang", "beck", "elmore", 'Gu'), #,"klos",
        verbose        = FALSE,
        wFUN           = options$wFUN_fine,
        nextend        = options$nextend_fine,
        maxExtendMonth = options$max_extend_month_fine,
        minExtendMonth = 1,
        minPercValid   = 0.2,
        print          = FALSE,
        use.rough      = options$use.rough
    )
    if (!is.function(param$wFUN)) param$wFUN %<>% get()

    fit  <- do.call(curvefits, param)

    params <- get_param(fit)
    stat   <- get_GOF(fit)                   # Goodness-Of-Fit
    pheno  <- get_pheno(fit, TRS = TRS, IsPlot=FALSE)   # Phenological metrics

    list(fit = fit, INPUT = INPUT, seasons = brks,
        param = params, stat = stat, pheno = pheno)
}

#' @param dateRange Date vector, filter input in the \code{dateRange}
#' @param nsite the max number of sites to process. \code{-1} means all sites.
#'
#' @rdname phenofit_process
#' @export
#'
#' @examples
#' \dontrun{
#' file_json <- system.file('shiny/phenofit/perference/phenofit_setting.json', package = "phenofit")
#' options <- setting.read(file_json)
#' r <- phenofit_process(options, nsite=2)
#' }
phenofit_process <- function(
    options,
    dateRange = c(as.Date('2010-01-01'), as.Date('2014-12-31')),
    nsite = -1,
    .progress = NULL, .parallel = FALSE,
    ...)
{
    showProgress <- !is.null(.progress) # this for shinyapp progress
    if (showProgress){
        on.exit(.progress$close())
        .progress$set(message = sprintf("phenofit (n=%d) | running ", n), value = 0)
    }

    rv    <- phenofit_loaddata(options, ...)
    sites <- rv$sites

    n     <- length(sites)
    if (nsite > 0) n <- pmin(n, nsite)

    FUN <- ifelse(.parallel, `%dopar%`, `%do%`)
    res <- FUN(foreach(i = 1:n, sitename = sites), {
        # sitename <- rv$sites[i]
        if (showProgress){
            progress$set(i, detail = paste("Doing part", i))
        }
        fprintf("phenofit (n = %d) | running %03d ... \n", i, n)

        tryCatch({
            INPUT <- with(rv, getsite_INPUT(df, st, sitename, nptperyear, dateRange))
            brks  <- phenofit_season(INPUT, options, IsPlot = FALSE)
            fits  <- phenofit_finefit(INPUT, brks, options) # multiple methods
            fits
        }, error = function(e){
            message(sprintf('[e] phenofit_process, site=%s: %s', sitename, e$message))
        }, warning = function(w){
            message(sprintf('[w] phenofit_process, site=%s: %s', sitename, w$message))
        })
    })

    ############################# CALCULATION FINISHED #####################
    set_names(res, sites[1:n])
}

#' get_date_AVHRR
#'
#' @importFrom lubridate days_in_month
#' @export
#'
#' @examples
#' date_AVHRR <- get_date_AVHRR()
get_date_AVHRR <- function(year_begin = 1982, year_end = 2015){
    dates <- seq(ymd(year_begin*1e4 + 0101), ymd(year_end*1e4 + 1231), "month")
    days  <- dates %>% days_in_month()

    dates_a <- dates + ddays(floor(days/4))
    dates_b <- dates + ddays(floor(days/4*3))
    dates <- c(dates_a, dates_b) %>% sort()

    d_dates <- data.table(I = seq_along(dates),
        date = dates, month = month(dates), dom = day(dates), doy = yday(dates))
    d_dates
}

#' phenofit_TSM.avhrr
#'
#' @param exportType could be one of \code{"all", "pheno"}. If "all" used, all
#' also will be exported. Note that exported fitting series is daily scale, which
#' is quite large.
#' 
#' @importFrom readr read_rds write_rds
#' @export
phenofit_TS.avhrr <- function(
    options,
    dateRange = c(as.Date('2010-01-01'), as.Date('2014-12-31')),
    I_part = NULL, 
    outdir = ".",
    exportType = "all", overwrite = FALSE, 
    .progress = NULL, .parallel = FALSE,
    ...)
{
    file_y  <- options$file_veg_text
    file_qc <- options$file_qc
    nptperyear <- options$nptperyear
    ymin       <- options$ymin

    d_date <- get_date_AVHRR()
    t <- d_date$date

    if (!is.null(dateRange)) {
        I_date <- which(t >= dateRange[1] & t <= dateRange[2])
    } else {
        I_date <- seq_along(t)
    }

    mat_y  <- fread(file_y, skip = 1) %>% as.matrix()
    mat_qc <- fread(file_qc, skip = 1) %>% as.matrix()

    if (is.null(I_part) || is.na(I_part)) {
        I_part <- 1:nrow(mat_qc)
    }
    mat_y  <- mat_y[I_part, ]
    mat_qc <- mat_qc[I_part, ]

    showProgress <- !is.null(.progress) # this for shinyapp progress
    if (showProgress){
        on.exit(.progress$close())
        .progress$set(message = sprintf("phenofit (n=%d) | running ", n), value = 0)
    }

    # rv    <- phenofit_loaddata(options, ...)
    # sites <- rv$sites
    # n     <- length(sites)

    n <- nrow(mat_y)
    if (nsite > 0) n <- pmin(n, nsite)
    sites <- seq_len(n) %>% as.character()

    FUN <- ifelse(.parallel, `%dopar%`, `%do%`)
    res <- FUN(foreach(
        y = iter(mat_y, by='row'),
        qc = iter(mat_qc, by='row'),
        i = I_part,
        .packages = c("phenofit")), {

        outfile <- sprintf("%s/phenofit_%05d.RDS", outdir, i)
        if (!file.exists(outfile) || overwrite) {
            # sitename <- rv$sites[i]
            if (showProgress){
                progress$set(i, detail = paste("Doing part", i))
            }
            fprintf("phenofit (n = %d) | running %03d ... \n", n, i)

            tryCatch({
                wmin <- 0.4
                l_w  <- qc_summary(qc[I_date], wmin = wmin, wmid = 0.5, wmax = 0.8)
                INPUT <- check_input(t[I_date], y[I_date], w = l_w$w, QC_flag = l_w$QC_flag,
                    nptperyear = nptperyear, south = FALSE, ymin = ymin, wmin = wmin)
                # INPUT <- with(rv, getsite_INPUT(df, st, sitename, nptperyear, dateRange))
                brks  <- phenofit_season(INPUT, options, IsPlot = FALSE, verbose = FALSE)
                fits  <- phenofit_finefit(INPUT, brks, options) # multiple methods
                if (exportType == "pheno") { fits <- fits[-(1:3)] }
                # fits
                write_rds(fits, outfile)
            # }, warning = function(w){
            #     message(sprintf('[w] phenofit_process, i=%d: %s', i, w$message))
            }, error = function(e){
                message(sprintf('[e] phenofit_process, i=%d: %s', i, e$message))
            })

        } else {
            fprintf("[file exist] : %s\n", basename(outfile))
        }
    })
    fprintf('Success finished!')
    ############################# CALCULATION FINISHED #####################
    # set_names(res, sites[1:n])
}

#' phenofit_plot
#'
#' @param obj \code{fFIT}
#' @param type one of c("season", "fitting", "pheno", "all")
#' @inheritParams plot_phenofit
#' @param show.legend If now show legend, ggplot object will be returned, else
#' grid object will be returned.
#'
#' @export
phenofit_plot <- function(obj, type = "all", methods,
    title = NULL, title.ylab = "Vegetation Index",
    Isplot = TRUE, show.legend = TRUE, newpage = TRUE){
    if (missing(methods) || is.null(methods)) {
        methods <- names(obj$fit[[1]]$fFIT)
    }

    g <- NULL
    plot_fitting <- function(){
        df_fit <- get_fitting(obj$fit)
        df_fit <- df_fit[meth %in% methods]

        g <- plot_phenofit(df_fit, obj$seasons, title, title.ylab, show.legend = show.legend)

        if (Isplot) {
            if (newpage) grid::grid.newpage()
            grid::grid.draw(g)
        }
        return(g)
    }

    if (type == "fitting") {
        g <- plot_fitting()
    } else if (type == "season") {
        plot_season(obj$INPUT, obj$seasons)
    } else if (type == "pheno") {
        l_pheno <- get_pheno(obj$fit, methods, IsPlot = T)
    } else if (type == "all") {
        # fitting
        g <- plot_fitting()
        # season
        plot_season(obj$INPUT, obj$seasons)
        # pheno
        l_pheno <- get_pheno(obj$fit, methods, IsPlot = T)
    } else {
        stop(sprintf("[e] wrong type: %sn", type))
    }
    return(g)
}
