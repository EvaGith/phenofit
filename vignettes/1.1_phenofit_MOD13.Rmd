---
title: "Extract vegetation phenology from MOD13A1 by `phenofit`"
author: "Dongdong Kong"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- ```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
``` -->


Here, we illustrate how to use `phenofit` to extract vegetation phenology from 
MOD13A1 in the sampled points. Regional analysis also can be conducted in the 
similar way.

# 1. Preparing input data

## 1.1 Download MOD13A1 data

Upload point shapefile into GEE, clip MOD13A1 and download vegetation index
data. [Here](https://code.earthengine.google.com/ee3ec39cf3061374dab435c358d008a3) is the corresponding GEE script. 

## 1.2 Initial weights for input data

Load packages.
```{r}
library(phenofit)
library(data.table)
library(magrittr)
library(lubridate)
library(maptools)
library(plyr)
```

Read the point shapefile to get points coordinate information. Read Enhanced 
Vegetation Index (EVI) exported by `GEE`.
```{r}
shpfile <- "st_20.shp"
st <- readShapePoints(shpfile) %>% 
    { data.table( set_colnames(coordinates(.), c("lon", "lat")), .@data)}

df <- fread('MOD13A1_st_20_0m_buffer.csv')
```

- Add date according to composite day of the year (DayOfYear), other than image date.
- Add weights according to `SummaryQA`. 

For MOD13A1, Weights can by initialed by `SummaryQA` band (also suit for 
MOD13A2 and MOD13Q1). We have written a qc function for `SummaryQA`, `qc_summary`.

SummaryQA      | Pixel reliability summary QA | weight
---------------| ---------------------------- | ------
-1 Fill/No data| Not processed                | `wmin`
0 Good data    | Use with confidence          | 1
1 Marginal data| Useful but look at detailed QA for more information | 0.5
2 Snow/ice     | Pixel covered with snow/ice  | `wmin`
3 Cloudy       | Pixel is cloudy              | `wmin`

```{r}
df[, `:=`(date = ymd(date), year = year(date), doy = as.integer(yday(date)))]
df[is.na(DayOfYear), DayOfYear := doy] # If DayOfYear is missing
    
# In case of last scene of a year, doy of last scene could in the next year
df[abs(DayOfYear - doy) >= 300, t := as.Date(sprintf("%d-%03d", year+1, DayOfYear), "%Y-%j")] # last scene
df[abs(DayOfYear - doy) <  300, t := as.Date(sprintf("%d-%03d", year  , DayOfYear), "%Y-%j")]

# MCD12Q1.006 land cover 1-17, IGBP scheme
IGBPnames <- c("ENF", "EBF", "DNF", "DBF", "MF" , "CSH", 
              "OSH", "WSA", "SAV", "GRA", "WET", "CRO", 
              "URB", "CNV", "SNOW", "BSV", "water", "UNC")

df <- df[, .(y = EVI/1e4, t, date, SummaryQA, IGBPcode, 
    IGBPname = as.factor(IGBPnames[IGBPcode]), Id)]
# merge coordinate info
df <- merge(df, st[, .(Id, lat, lon)], by = "Id")

# Initial weights
df[, w := qc_summary(SummaryQA)]
# Remap SummaryQA factor level, plot_phenofit use this variable. For other 
# remote sensing data without `SummaryQA`, need to modify `plot_phenofit`
if ('SummaryQA' %in% colnames(df)){
    values <- c("0", "1", "2", "3")
    levels <- c(" good", " margin", " snow&ice", " cloud")
    df$SummaryQA %<>% factor() %>% mapvalues(values, levels)
}
```

Add one year in head and tail, for growing season dividing. For example, the 
input data period is 20000218 ~ 20171219. After adding one year in head and 
tail, it becomes 19990101 ~ 20181219. 

# 2. Running `phenofit`
## 2.1 Set global parameters for `phenofit`

```{r}
# lambda   <- 5    # Whittaker parameter
ymax_min   <- 0.1  # the maximum ymax shoud be greater than `ymax_min` 
rymin_less <- 0.6  # trough < ymin + A*rymin_less
nptperyear <- 23   # How many points for a single year
wFUN       <- wTSM # Weights updating function, could be one of `wTSM`, 'wBisquare', `wChen` and `wSELF`. 

Ids        <- unique(df$Id)
Id         <- df$Id[1]
d          <- df[Id == Ids[1], ] # get the first site data
```

```{r}
```

```{r}
 # for mapvalues
source("../R/PhenoBrks.R")
source("../test/GEE/test-func.R")
source("../test/GEE/pkg_seasonality.R")

d     <- dt[site == sites[3], ] # get the first site data
# knitr::kable(head(d, 10)) 
```

## 2.2. Backgroud value
```{r, echo=F}
d$Tn %<>% na.approx(maxgap = 4)
plot(d$Tn, type = "l"); abline(a = 5, b = 0, col = "red")
```

### 2. Divide growing seasons

Simply treating calendar year as a complete growing season will induce a considerable error for phenology extraction. A simple growing season dividing method was proposed in `phenofit`.

The growing season dividing method rely on heavily in Whittaker smoother. 

Procedures of initial weight, growing season dividing and curve fitting are separated. Phenology extraction and curve fitting are combined together.

```{r}
# d     <- df[site == sitename , ]
dnew  <- add_HeadTail(d)
# 1. Check input data and initial parameters for phenofit
INPUT <- check_input(dnew$t, dnew$y, dnew$w, maxgap = nptperyear/4, alpha = 0.02)
INPUT$y0 <- dnew$y

# 2. The detailed information of those parameters can be seen in `season`.
lambda <- init_lambda(INPUT$y)#*2
brks   <- season(INPUT, nptperyear,
               FUN = whitsmw2, wFUN = wFUN, iters = 2, 
               lambda = lambda,
               IsPlot = T, plotdat = d, 
               south = d$lat[1] < 0,
               rymin_less = 0.6, ymax_min = ymax_min,
               max_MaxPeaksperyear =2.5, max_MinPeaksperyear = 3.5) #, ...
# get growing season breaks in a 3-year moving window
brks2 <- season_3y(INPUT, nptperyear, FUN = whitsmw2, 
                   IsPlot = T, south = d$lat[1] < 0, partial = F)

# 3. curve fitting
fit  <- curvefits(INPUT, brks2, lambda =lambda, IsPlot = T,
                  methods = c("AG", "zhang", "beck", "elmore", 'Gu'), #,"klos"
                  nptperyear = nptperyear, debug = F, wFUN = wTSM,
                  ymax_min = ymax_min,
                  extend_month = 2,
                  qc = as.numeric(dnew$SummaryQA), minPercValid = 0, 
                  south = d$lat[1] < 0)
fit$INPUT   <- INPUT
fit$seasons <- brks2

plot_phenofit(fit, d) %>% grid::grid.draw()# plot to check the curve fitting
temp <- ExtractPheno(fit$fits$ELMORE[1:5], IsPlot = T) # check extracted phenology

## 3.2 Get GOF information
stat  <- ldply(fit$fits, function(fits_meth){
    ldply(fits_meth, statistic.phenofit, .id = "flag")
}, .id = "meth")

# 4. extract phenology, check extracted phenology extraction for one method.
ratio = 1.15
file <- "Figure5_Phenology_Extraction_temp.pdf"
cairo_pdf(file, 8*ratio, 6*ratio)
temp <- ExtractPheno(fit$fits$ELMORE[2:6], IsPlot = T)
dev.off()
file.show(file)

# pheno: list(p_date, p_doy)
p <- lapply(fit$fits, ExtractPheno)
pheno  <- map(p, tidyFitPheno, origin = t[1]) %>% purrr::transpose()

fit$stat   <- stat
fit$pheno  <- pheno
```

Calculate all sites in a time.
```{r}
ratio    <- 1.8
lambda   <- 2
sites_sm <- sites[c(1, 3, 4, 6, 9)]
df_sm    <- df[site %in% sites_sm, ]

Cairo::CairoPDF("phenofit_5st_v4.pdf", 10*ratio, 6*ratio)
fits <- dlply(df_sm, .(site), function(d){
    fit <- NA
    tryCatch({
        # Check input data and initial parameters for phenofit
        INPUT <- check_input(d$date, d$y, d$w, trim = T, maxgap = nptperyear / 4, alpha = 0.02)
        # The detailed information of those parameters can be seen in `season`. 
        brks <- season(INPUT, lambda, nptperyear, iters = 3, wFUN = wFUN, IsPlot = F,
                        south = d$lat[1] < 0,
                        Aymin_less = 0.6, ymax_min = ymax_min, 
                        max_MaxPeaksperyear =2.5, max_MinPeaksperyear = 3.5) #, ...
        fit  <- curvefits(INPUT, brks, lambda =lambda, IsPlot = T, 
                          methods = c("AG", "zhang", "beck", "elmore", 'Gu'), #,"klos"
                          nptperyear = nptperyear, debug = F, 
                          wFUN = wFUN, 
                          extend_month = 2, 
                          south = d$lat[1] < 0)
        fit$INPUT   <- INPUT
        fit$seasons <- brks

        titlename <- sprintf('[%s] %s', d$IGBP[1], d$site[1])
        p <- plot_phenofit(fit, d, titlename)
        print(p)
    }, error = function(e){
        message(sprintf("[e] %s:%s", e$message, d$site[1]))
    })
    return(fit)
})
dev.off()
```

You can also call `curvefits2`, which combines all the procedures.   
```{r}
south <- d$lat[1] < 0
fit <- curvefits2(d$date, d$y, d$w, nptperyear = nptperyear,
           wFUN = wFUN, iters = 2,
           lambda = lambda, south = FALSE,
           IsPlot = FALSE,
           Aymin_less = 0.6, ymax_min = ymax_min, 
           methods = c('AG', 'zhang', 'beck', 'elmore', 'Gu'),
           debug = FALSE)
```

Test backgroud value function here

```{r}
profvis::profvis({
        fit <- curvefits2(d$date, d$y, d$w, nptperyear = nptperyear,
                   wFUN = wFUN, iters = 2,
                   lambda = lambda, south = FALSE,
                   IsPlot = FALSE,
                   Aymin_less = 0.6, ymax_min = ymax_min, 
                   methods = c('AG', 'zhang', 'beck', 'elmore', 'Gu')[4],
                   debug = FALSE)
})
```

```{r}
params <- getparam(fit)
print(params)
```
